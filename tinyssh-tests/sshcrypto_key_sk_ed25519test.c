/*
20440414
Jó Ágila Bitsch
Public domain.
*/

#include <unistd.h>
#include <string.h>
#include "fail.h"
#include "sshcrypto.h"

static unsigned char authorized_keys[129] = "sk-ssh-ed25519@openssh.com AAAAGnNrLXNzaC1lZDI1NTE5QG9wZW5zc2guY29tAAAAINNQKmYkYiy++sy5lWeN+N0SJsaDWPx9JYqlRgiZKbVlAAAABHNzaDo=\n";
static unsigned char id_sk_ed25519_bin[78] = {
    0x00, 0x00, 0x00, 0x4a,  // -> uint32 length (of the public key bytes to follow)
    0x00, 0x00, 0x00, 0x1a,  //-> uint32 length (of the public key type string)
    0x73, 0x6b, 0x2d, 0x73, 0x73, 0x68, 0x2d, 0x65,
    0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x40, 0x6f,
    0x70, 0x65, 0x6e, 0x73, 0x73, 0x68, 0x2e, 0x63,
    0x6f, 0x6d,              // -> string "sk-ssh-ed25519@openssh.com"
    0x00, 0x00, 0x00, 0x20,  // -> uint32 length (of the public key bytes)
    0xd3, 0x50, 0x2a, 0x66, 0x24, 0x62, 0x2c, 0xbe,
    0xfa, 0xcc, 0xb9, 0x95, 0x67, 0x8d, 0xf8, 0xdd,
    0x12, 0x26, 0xc6, 0x83, 0x58, 0xfc, 0x7d, 0x25,
    0x8a, 0xa5, 0x46, 0x08, 0x99, 0x29, 0xb5, 0x65,  // -> 32 bytes of a ed25519 public key
    0x00, 0x00, 0x00, 0x04,  // -> uint32 length of application string
    0x73, 0x73, 0x68, 0x3a,  // -> application string "ssh:"

};
static unsigned char signature[107] = {
    0x00, 0x00, 0x00, 0x67,  // -> uint32 length (of the signature bytes to follow)
    0x00, 0x00, 0x00, 0x1a,  // -> uint32 length (of the signature algorithm name)
    0x73, 0x6b, 0x2d, 0x73, 0x73, 0x68, 0x2d, 0x65,
    0x64, 0x32, 0x35, 0x35, 0x31, 0x39, 0x40, 0x6f,
    0x70, 0x65, 0x6e, 0x73, 0x73, 0x68, 0x2e, 0x63,
    0x6f, 0x6d,              // -> string "sk-ssh-ed25519@openssh.com"
    0x00, 0x00, 0x00, 0x40,  // -> uint32 length(=64) of signature itself
    0x9c, 0xd3, 0xa1, 0xd9, 0xdc, 0x01, 0xcb, 0xdd,
    0x0e, 0xe7, 0xbd, 0x29, 0x58, 0xcb, 0x79, 0x4a,
    0x75, 0xd8, 0xb4, 0xef, 0x3b, 0x57, 0x24, 0xbe,
    0x20, 0x39, 0x46, 0x0a, 0xdf, 0xcf, 0x15, 0x34,
    0x38, 0xff, 0xe7, 0xcf, 0x0e, 0xa3, 0x1b, 0x2b,
    0x75, 0xfd, 0x18, 0xd4, 0xab, 0x2a, 0x74, 0xc0,
    0xab, 0x7f, 0x39, 0xc0, 0x0f, 0x66, 0x5d, 0x60,
    0x11, 0x4d, 0xbb, 0xd8, 0xb8, 0xda, 0x4c, 0x05,  // -> bytes of the signature
    0x01,  // -> (byte) flags -> user present
    0x00, 0x00, 0x00, 0x08,  // -> uint32 counter
};
static unsigned char message[96] = {  // SSHSIG over the authorized_keys 
    0x53, 0x53, 0x48, 0x53, 0x49, 0x47, 0x00, 0x00,
    0x00, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x73, 0x68,
    0x61, 0x35, 0x31, 0x32, 0x00, 0x00, 0x00, 0x40,
    0xa8, 0x0b, 0xb9, 0xab, 0x9d, 0xbc, 0x68, 0xa3,
    0xef, 0x64, 0x18, 0x53, 0x22, 0xee, 0x31, 0xb0,
    0x39, 0x26, 0x03, 0x39, 0x25, 0x29, 0x4e, 0xa9,
    0x1b, 0xba, 0x3b, 0x6f, 0xf4, 0xb2, 0x7a, 0x90,
    0xb5, 0xf5, 0xce, 0x5f, 0x4b, 0x15, 0xb5, 0xab,
    0x98, 0xf5, 0xb9, 0x4c, 0xa3, 0x2f, 0x59, 0xbd,
    0xa0, 0x1d, 0xc0, 0x42, 0x6d, 0xd6, 0x32, 0x35,
    0xf0, 0x94, 0x0a, 0x5f, 0xe0, 0xe9, 0x83, 0xdf,
};

static void test_signopen(void) {
    unsigned char pk[crypto_sign_ed25519_PUBLICKEYBYTES + 16];
    unsigned char sig[69];
    unsigned char buf_array[1024];
    struct buf buf;
//    unsigned long long len;
    unsigned char om[1024];
    unsigned long long omlen;

    buf_init(&buf, buf_array, sizeof buf_array);

    sk_ed25519_parsesignpk(pk, id_sk_ed25519_bin + 4, sizeof id_sk_ed25519_bin - 4);
    sk_ed25519_putsignpk(&buf, pk);
    if (memcmp(buf.buf, id_sk_ed25519_bin, sizeof id_sk_ed25519_bin)){
        fail_printdata("id", id_sk_ed25519_bin, sizeof id_sk_ed25519_bin);
        fail_printdata("buf", buf.buf, buf.len);
        fail("sk_ed25519_putsignpk() failure, please report it !!!!!!!!!");
    }
    buf_purge(&buf);

    sk_ed25519_putsignpkbase64(&buf,pk);
    if (memcmp(buf.buf, authorized_keys + 27, sizeof authorized_keys - 29)){
        fail_printdata("ak", authorized_keys, sizeof authorized_keys);
        fail_printdata("buf", buf.buf, buf.len);
        fail("sk_ed25519_putsignpkbase64() failure, please report it !!!!!!!!!");
    }
    buf_purge(&buf);


    sk_ed25519_parsesignature(sig, signature + 4, sizeof signature - 4);
    sk_ed25519_putsignature(&buf, sig);
    if (memcmp(buf.buf, signature, sizeof signature)){
        fail_printdata("insig", signature, sizeof signature);
        fail_printdata("sig", sig, 69);
        fail_printdata("buf", buf.buf, buf.len);
        fail("sk_ed25519_putsignature() failure, please report it !!!!!!!!!");
    }
    buf_purge(&buf);


    buf_put(&buf, sig, sizeof sig);
    buf_put(&buf, message, sizeof message);

    if (sk_ed25519_open(om, &omlen, buf.buf, buf.len, pk) != 0) {
        fail_printdata("sm", buf.buf, buf.len);
        fail_printdata("pk", pk, crypto_sign_ed25519_PUBLICKEYBYTES);
        fail("sk_ed25519_open() failure, please report it !!!!!!!!!");
    }

    if (memcmp(buf.buf + 69, om, omlen)) {
        fail_printdata("m", buf.buf, omlen);
        fail_printdata("om", om, omlen);
        fail("sk_ed25519_open() failure, messages do not match");
    }
}


int main(void) {

    test_signopen();
    _exit(0);
}
